# DSPy 代码检视功能

## 项目概述

本项目使用 DSPy 框架实现一个智能代码检视系统，通过自动化分析代码变更来提高代码质量和发现潜在问题。

## 功能模块

### 1. Git 分支新增函数检测

**目标**: 自动识别当前分支相比基准分支新增的所有函数

**实现要点**:
- 使用 git diff 分析代码变更
- 解析新增的函数定义（支持多种编程语言）
- 识别函数签名、参数、返回值等信息
- 过滤掉删除和修改的函数，只保留新增函数

**输入**:
- 基准分支名称（如 main/master）
- 当前工作分支名称

**输出**:
- 新增函数列表，包含文件路径、函数名、行号等元数据

---

### 2. 生成函数检查清单

**目标**: 将检测到的新增函数组织成结构化的检查清单文件

**实现要点**:
- 创建 JSON/YAML 格式的 checklist 文件
- 为每个函数记录详细信息：
  - 文件路径
  - 函数名称
  - 起始行号和结束行号
  - 函数签名
  - 检查状态（待检查/已检查）

**输入**:
- 新增函数列表

**输出**:
- `code_review_checklist.json` 文件

---

### 3. 构建函数调用关系图

**目标**: 分析新增函数与现有模块之间的调用关系

**实现要点**:
- 静态代码分析找出函数内部调用的其他函数
- 反向搜索：查找调用新增函数的现有代码
- 构建调用关系图（call graph）
- 识别依赖的模块和被依赖的模块

**输入**:
- 函数检查清单
- 代码库的完整代码

**输出**:
- 函数调用关系图（JSON 格式）
- 依赖关系可视化数据

---

### 4. Bug 检测与分析

**目标**: 使用 DSPy 识别新增函数及其影响范围内的潜在 bug

**实现要点**:
- **内部 Bug 检测**:
  - 空指针/None 值检查
  - 边界条件处理
  - 异常处理完整性
  - 资源泄漏（文件、连接等）
  - 逻辑错误和死代码

- **模块间 Bug 检测**:
  - 接口不匹配
  - 类型不兼容
  - 调用顺序问题
  - 状态管理冲突
  - 并发安全问题

**使用 DSPy**:
- 设计专门的 Bug 检测 Signature
- 使用 Chain of Thought 提示进行推理
- 利用 Few-shot 学习提供示例

**输入**:
- 新增函数代码
- 函数调用关系图
- 相关模块代码

**输出**:
- 潜在 bug 列表，包含：
  - Bug 类型
  - 严重程度（高/中/低）
  - 位置信息
  - 问题描述

---

### 5. 修改建议生成

**目标**: 针对检测到的 bug 提供具体的修改建议

**实现要点**:
- 为每个 bug 生成修复建议
- 提供代码示例（before/after）
- 考虑最佳实践和设计模式
- 优先级排序

**使用 DSPy**:
- 设计修复建议生成的 Signature
- 使用 ReAct 或 Chain of Thought 模式
- 结合代码上下文生成针对性建议

**输入**:
- 潜在 bug 列表
- 相关代码上下文

**输出**:
- 修改建议列表，包含：
  - 问题说明
  - 修复方案
  - 代码示例
  - 优先级

---

### 6. 生成检视报告

**目标**: 整合所有分析结果，生成完整的代码检视报告

**实现要点**:
- 汇总所有检测结果
- 生成结构化的 Markdown/HTML 报告
- 包含统计信息和可视化图表
- 提供可执行的行动项

**报告内容**:
1. **概要信息**
   - 新增函数数量
   - 检测到的 bug 总数
   - 严重 bug 数量

2. **详细分析**
   - 每个新增函数的检查结果
   - 调用关系图
   - Bug 详情和修改建议

3. **统计图表**
   - Bug 类型分布
   - 严重程度分布
   - 模块影响范围

4. **行动建议**
   - 优先修复项
   - 代码改进建议
   - 后续跟进事项

**输入**:
- 所有前述步骤的输出结果

**输出**:
- `code_review_report.md` 综合报告
- `code_review_report.html` 可视化报告（可选）

---

## 实施计划

本项目采用迭代开发方式，逐步实现各个功能模块：

1. **第一阶段**: 实现 Git 分支新增函数检测
2. **第二阶段**: 实现函数检查清单生成
3. **第三阶段**: 实现函数调用关系构建
4. **第四阶段**: 实现 Bug 检测与分析
5. **第五阶段**: 实现修改建议生成
6. **第六阶段**: 实现检视报告生成
7. **第七阶段**: 使用 GEPA 优化整个系统

每个阶段完成后进行测试和优化，确保功能稳定可靠。

---

## DSPy 优化配置 (GEPA)

在所有功能模块实现完成后，使用 **GEPA (Generalized Evaluation and Prompt Adaptation)** 对整个代码检视系统进行优化。

### 优化目标

提升代码检视系统在以下方面的性能：
- Bug 检测的准确率和召回率
- 修改建议的质量和可操作性
- 整体分析速度和效率
- 降低误报率（False Positives）

### GEPA 优化步骤

#### 1. 数据集准备

**训练集构建**:
- 收集历史代码变更和真实的 bug 案例
- 标注已知的 bug 和正确的修复方案
- 包含多种编程语言和项目类型
- 划分为训练集、验证集和测试集

**示例数据格式**:
```json
{
  "function_code": "...",
  "call_graph": {...},
  "known_bugs": [...],
  "correct_suggestions": [...],
  "severity": "high/medium/low"
}
```

#### 2. 评估指标定义

定义各模块的评估指标：

**Bug 检测模块**:
- Precision（精确率）：检测出的 bug 中真实 bug 的比例
- Recall（召回率）：所有真实 bug 中被检测出的比例
- F1-Score：精确率和召回率的调和平均

**修改建议模块**:
- 建议的可执行性（是否能直接应用）
- 建议的完整性（是否完全解决问题）
- 代码质量改进度

**整体系统**:
- 端到端准确率
- 处理时间
- 用户满意度评分

#### 3. GEPA 优化配置

**配置 Optimizer**:
```python
from dspy.teleprompt import GEPA

# 定义评估函数
def evaluate_bug_detection(example, prediction):
    # 评估逻辑
    return score

# 配置 GEPA 优化器
gepa_optimizer = GEPA(
    metric=evaluate_bug_detection,
    breadth=10,  # 搜索广度
    depth=3,     # 搜索深度
    max_iterations=50
)

# 执行优化
optimized_program = gepa_optimizer.compile(
    code_review_program,
    trainset=training_data,
    valset=validation_data
)
```

#### 4. 优化各个功能模块

**模块级优化**:
- Bug 检测模块的 Signature 和 Prompt 优化
- 调用关系分析的准确性优化
- 修改建议生成的质量优化

**系统级优化**:
- 端到端流程优化
- 模块间协调优化
- 输出格式和可读性优化

#### 5. 性能评估与迭代

**评估流程**:
1. 在测试集上评估优化后的模型
2. 分析各类 bug 的检测效果
3. 对比优化前后的性能提升
4. 识别需要进一步改进的领域

**持续优化**:
- 定期收集新的代码样本和反馈
- 更新训练数据集
- 重新执行 GEPA 优化
- 版本管理和 A/B 测试

#### 6. 优化结果保存与部署

**保存优化结果**:
```python
# 保存优化后的程序
optimized_program.save('models/optimized_code_review.json')

# 保存优化历史和指标
metrics_history = {
    'precision': [...],
    'recall': [...],
    'f1_score': [...],
    'optimization_iterations': 50
}
```

**部署策略**:
- 灰度发布：先在小范围测试
- 监控关键指标：准确率、响应时间
- 回滚机制：性能下降时快速回退
- 持续监控：收集用户反馈和使用数据

### 优化预期效果

通过 GEPA 优化，预期达到：
- Bug 检测准确率提升 **15-30%**
- 误报率降低 **20-40%**
- 修改建议采纳率提升 **25-35%**
- 整体处理速度优化 **10-20%**

### 优化最佳实践

1. **从小规模开始**: 先在单个模块上应用 GEPA，验证效果后再扩展
2. **高质量数据**: 确保训练数据的准确性和多样性
3. **合理的评估指标**: 选择与实际应用场景匹配的指标
4. **迭代优化**: 持续收集反馈，定期重新优化
5. **版本控制**: 保存每次优化的配置和结果，便于对比和回滚

---

## 技术栈

- **DSPy**: 核心推理和分析框架
- **GEPA**: DSPy 优化器，用于提升系统性能
- **Git**: 版本控制和代码变更检测
- **AST 解析**: 代码结构分析（ast, tree-sitter 等）
- **静态分析工具**: 辅助 bug 检测
- **LLM**: 代码理解和建议生成

## 预期收益

- 自动化代码检视流程，提高效率
- 及早发现潜在问题，降低线上风险
- 提供可操作的改进建议，提升代码质量
- 积累代码检视知识库，持续优化检测能力
